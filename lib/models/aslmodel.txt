import 'dart:typed_data';
import 'package:camera/camera.dart';
import 'package:image/image.dart' as img;
import 'package:tflite_flutter/tflite_flutter.dart';

class AslModel {
  late Interpreter _interpreter;
  late List<int> inputShape;
  late List<int> outputShape;

  Future<void> loadModel() async {
    _interpreter = await Interpreter.fromAsset('assets/asl/asl_model.tflite');
    inputShape = _interpreter.getInputTensor(0).shape;
    outputShape = _interpreter.getOutputTensor(0).shape;
    print('Model Loaded: Input: $inputShape Output: $outputShape');
  }

  String runInference(List<double> input) {
    var output = List.filled(outputShape.reduce((a, b) => a * b), 0.0).reshape(outputShape);

    _interpreter.run([input], output);

    List<double> probabilities = List<double>.from(output[0]);
    int maxIndex = probabilities.indexWhere(
            (e) => e == probabilities.reduce((a, b) => a > b ? a : b));

    // Replace with your actual labels
    List<String> labels = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
      "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",
      "U", "V", "W", "X", "Y", "Z", "del", "nothing", "space"];
    return labels[maxIndex];
  }

  /// Converts [CameraImage] in YUV420 format to a normalized Float32 list
  Future<List<double>> preprocess(CameraImage image) async {
    // Convert YUV420 to RGB image using the `image` package
    final img.Image rgbImage = _convertYUV420toImage(image);

    // Resize to model input (224x224)
    final resizedImage = img.copyResize(rgbImage, width: 224, height: 224);

    // Normalize and flatten
    final List<double> input = List.filled(224 * 224 * 3, 0);
    int index = 0;
    for (int y = 0; y < 224; y++) {
      for (int x = 0; x < 224; x++) {
        final pixel = resizedImage.getPixel(x, y);
        final r = pixel.r;
        final g = pixel.g;
        final b = pixel.b;

        input[index++] = (r - 127.5) / 127.5;
        input[index++] = (g - 127.5) / 127.5;
        input[index++] = (b - 127.5) / 127.5;
      }
    }

    return input;
  }

  img.Image _convertYUV420toImage(CameraImage cameraImage) {
    final int width = cameraImage.width;
    final int height = cameraImage.height;

    final img.Image image = img.Image(width: width, height: height);

    final Uint8List y = cameraImage.planes[0].bytes;
    final Uint8List u = cameraImage.planes[1].bytes;
    final Uint8List v = cameraImage.planes[2].bytes;

    final int uvRowStride = cameraImage.planes[1].bytesPerRow;
    final int uvPixelStride = cameraImage.planes[1].bytesPerPixel!;

    for (int yIdx = 0; yIdx < height; yIdx++) {
      for (int xIdx = 0; xIdx < width; xIdx++) {
        final int uvIndex = uvPixelStride * (xIdx ~/ 2) + uvRowStride * (yIdx ~/ 2);
        final int yp = y[yIdx * width + xIdx];
        final int up = u[uvIndex];
        final int vp = v[uvIndex];

        int r = (yp + (1.370705 * (vp - 128))).toInt();
        int g = (yp - (0.698001 * (vp - 128)) - (0.337633 * (up - 128))).toInt();
        int b = (yp + (1.732446 * (up - 128))).toInt();

        image.setPixelRgb(xIdx, yIdx, r.clamp(0, 255), g.clamp(0, 255), b.clamp(0, 255));
      }
    }

    return image;
  }
}
